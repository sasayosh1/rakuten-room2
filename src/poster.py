#!/usr/bin/env python3
"""Ê•ΩÂ§©ROOMÊäïÁ®ø„Éú„ÉÉ„Éà"""

import base64
import json
import os
import random
import time
import logging
from datetime import datetime, date
from pathlib import Path
from typing import List, Dict
import gspread
from playwright.sync_api import sync_playwright


class RoomPoster:
    """Ê•ΩÂ§©ROOMÊäïÁ®ø„Éú„ÉÉ„Éà"""
    
    def __init__(self):
        """ÂàùÊúüÂåñ"""
        # Áí∞Â¢ÉÂ§âÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
        required_vars = ["ROOM_EMAIL", "ROOM_PASSWORD", "GSA_JSON_B64", "GSPREAD_KEY"]
        for var in required_vars:
            if not os.environ.get(var):
                raise ValueError(f"Áí∞Â¢ÉÂ§âÊï∞ {var} „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
        
        # Google SheetsË®≠ÂÆö
        sa_json_b64 = os.environ["GSA_JSON_B64"]
        sa_info_json = base64.b64decode(sa_json_b64)
        sa_info = json.loads(sa_info_json)
        self.gc = gspread.service_account_from_dict(sa_info)
        self.sh = self.gc.open_by_key(os.environ["GSPREAD_KEY"])
        
        self.daily_limit = 1  # 1Êó•ÊúÄÂ§ßÊäïÁ®øÊï∞ÔºàÂÆâÂÖ®ÊÄßÈáçË¶ñÔºâ
        self.stats_file = Path("daily_stats.json")
        self.error_file = Path("error_tracking.json")
        self.max_consecutive_errors = 3  # ÈÄ£Á∂öÂ§±Êïó‰∏äÈôê
        self.suspension_hours = 24  # ÂÅúÊ≠¢ÊôÇÈñìÔºàÊôÇÈñìÔºâ
        self.dry_run = os.environ.get("DRY_RUN", "false").lower() == "true"  # „Éâ„É©„Ç§„É©„É≥„É¢„Éº„Éâ
        self.gradual_mode = os.environ.get("GRADUAL_MODE", "true").lower() == "true"  # ÊÆµÈöéÁöÑÂÆüË°å„É¢„Éº„Éâ
        self.success_threshold = 0.8  # 80%‰ª•‰∏ä„ÅÆÊàêÂäüÁéá„ÅßÊäïÁ®øÈñãÂßã
        
        # „É≠„Ç∞Ë®≠ÂÆö
        self.setup_logging()
        
        # Áõ£Ë¶ñË®≠ÂÆö
        self.metrics_file = Path("performance_metrics.json")
        self.health_thresholds = {
            'success_rate_warning': 0.7,  # 70%Êú™Ê∫Ä„ÅßË≠¶Âëä
            'success_rate_critical': 0.5,  # 50%Êú™Ê∫Ä„ÅßÁ∑äÊÄ•
            'consecutive_errors_warning': 2,
            'consecutive_errors_critical': 3
        }
    
    def setup_logging(self):
        """„É≠„Ç∞Ë®≠ÂÆö"""
        log_level = os.environ.get("LOG_LEVEL", "INFO").upper()
        log_file = f"room_poster_{date.today().isoformat()}.log"
        
        logging.basicConfig(
            level=getattr(logging, log_level, logging.INFO),
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        self.logger.info("=== Ê•ΩÂ§©ROOMÊäïÁ®ø„Éú„ÉÉ„ÉàÈñãÂßã ===")
    
    def log_action(self, action: str, details: dict = None, level: str = "INFO"):
        """Ë©≥Á¥∞„É≠„Ç∞Ë®òÈå≤"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'dry_run': self.dry_run,
            'gradual_mode': self.gradual_mode,
            'daily_limit': self.daily_limit
        }
        
        if details:
            log_entry.update(details)
        
        # „É≠„Ç∞„Éï„Ç°„Ç§„É´„Å´JSONÂΩ¢Âºè„ÅßË®òÈå≤
        log_json_file = f"detailed_log_{date.today().isoformat()}.jsonl"
        with open(log_json_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")
        
        # Ê®ôÊ∫ñ„É≠„Ç∞„Å´„ÇÇÂá∫Âäõ
        log_message = f"{action}: {json.dumps(details, ensure_ascii=False) if details else ''}"
        getattr(self.logger, level.lower(), self.logger.info)(log_message)
    
    def get_daily_stats(self) -> Dict:
        """Êú¨Êó•„ÅÆÊäïÁ®øÁµ±Ë®àÂèñÂæó"""
        today = date.today().isoformat()
        
        if self.stats_file.exists():
            with open(self.stats_file, "r", encoding="utf-8") as f:
                stats = json.load(f)
        else:
            stats = {}
        
        if today not in stats:
            stats[today] = {"posts": 0, "last_post": None}
        
        return stats[today]
    
    def update_daily_stats(self, posts_count: int):
        """ÊäïÁ®øÁµ±Ë®àÊõ¥Êñ∞"""
        today = date.today().isoformat()
        
        if self.stats_file.exists():
            with open(self.stats_file, "r", encoding="utf-8") as f:
                stats = json.load(f)
        else:
            stats = {}
        
        stats[today] = {
            "posts": posts_count,
            "last_post": datetime.now().isoformat()
        }
        
        with open(self.stats_file, "w", encoding="utf-8") as f:
            json.dump(stats, f, ensure_ascii=False, indent=2)
    
    def check_suspension_status(self) -> bool:
        """ÂÅúÊ≠¢Áä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        if not self.error_file.exists():
            return False
        
        with open(self.error_file, "r", encoding="utf-8") as f:
            error_data = json.load(f)
        
        suspended_until = error_data.get("suspended_until")
        if suspended_until:
            suspend_time = datetime.fromisoformat(suspended_until)
            if datetime.now() < suspend_time:
                print(f"‚è∏Ô∏è  „Ç∑„Çπ„ÉÜ„É†ÂÅúÊ≠¢‰∏≠ÔºàËß£Èô§‰∫àÂÆö: {suspended_until}Ôºâ")
                return True
        
        return False
    
    def record_error(self, error_type: str, error_msg: str):
        """„Ç®„É©„ÉºË®òÈå≤"""
        if self.error_file.exists():
            with open(self.error_file, "r", encoding="utf-8") as f:
                error_data = json.load(f)
        else:
            error_data = {"consecutive_errors": 0, "last_errors": []}
        
        # „Ç®„É©„ÉºË®òÈå≤Êõ¥Êñ∞
        error_data["consecutive_errors"] += 1
        error_data["last_errors"].append({
            "timestamp": datetime.now().isoformat(),
            "type": error_type,
            "message": error_msg
        })
        
        # Áõ¥Ëøë10‰ª∂„ÅÆ„Åø‰øùÊåÅ
        error_data["last_errors"] = error_data["last_errors"][-10:]
        
        # ÈÄ£Á∂öÂ§±Êïó„Åå‰∏äÈôê„Å´ÈÅî„Åó„Åü„ÇâÂÅúÊ≠¢
        if error_data["consecutive_errors"] >= self.max_consecutive_errors:
            from datetime import timedelta
            suspend_until = datetime.now() + timedelta(hours=self.suspension_hours)
            error_data["suspended_until"] = suspend_until.isoformat()
            print(f"üö® ÈÄ£Á∂öÂ§±Êïó{self.max_consecutive_errors}Âõû„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ{self.suspension_hours}ÊôÇÈñìÂÅúÊ≠¢„Åó„Åæ„Åô„ÄÇ")
        
        with open(self.error_file, "w", encoding="utf-8") as f:
            json.dump(error_data, f, ensure_ascii=False, indent=2)
    
    def record_success(self):
        """ÊàêÂäüË®òÈå≤Ôºà„Ç®„É©„Éº„Ç´„Ç¶„É≥„Çø„É™„Çª„ÉÉ„ÉàÔºâ"""
        if self.error_file.exists():
            with open(self.error_file, "r", encoding="utf-8") as f:
                error_data = json.load(f)
            
            # ÈÄ£Á∂ö„Ç®„É©„Éº„Ç´„Ç¶„É≥„Çø„Çí„É™„Çª„ÉÉ„Éà
            error_data["consecutive_errors"] = 0
            if "suspended_until" in error_data:
                del error_data["suspended_until"]
            
            with open(self.error_file, "w", encoding="utf-8") as f:
                json.dump(error_data, f, ensure_ascii=False, indent=2)
    
    def dry_run_mode(self, products: List[Dict]) -> int:
        """„Éâ„É©„Ç§„É©„É≥„É¢„Éº„ÉâÔºöÊäïÁ®ø„Çí„Ç∑„Éü„É•„É¨„Éº„Éà"""
        print("üß™ „Éâ„É©„Ç§„É©„É≥„É¢„Éº„ÉâÔºöÂÆüÈöõ„ÅÆÊäïÁ®ø„ÅØË°å„ÅÑ„Åæ„Åõ„Çì")
        print(f"üìä ÊäïÁ®ø‰∫àÂÆöÂïÜÂìÅÊï∞: {len(products)}")
        print("-" * 50)
        
        for i, product in enumerate(products, 1):
            print(f"{i}. „Äê{product.get('category', '„Ç´„ÉÜ„Ç¥„É™‰∏çÊòé')}„Äë")
            print(f"   „Çø„Ç§„Éà„É´: {product['title'][:50]}{'...' if len(product['title']) > 50 else ''}")
            print(f"   URL: {product['url']}")
            print(f"   Ë™¨Êòé: {product['description'][:100]}{'...' if len(product['description']) > 100 else ''}")
            print()
        
        print("‚úÖ „Éâ„É©„Ç§„É©„É≥ÂÆå‰∫ÜÔºö„Åô„Åπ„Å¶„ÅÆÂïÜÂìÅ„ÅåÊäïÁ®øÂèØËÉΩ„Å™Áä∂ÊÖã„Åß„Åô")
        return len(products)  # „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÊàêÂäü„Å®„Åó„Å¶‰ª∂Êï∞„ÇíËøî„Åô
    
    def calculate_success_rate(self, days_back: int = 7) -> dict:
        """Ë©≥Á¥∞„Å™ÊàêÂäüÁéáË®àÁÆó"""
        metrics = {
            'current_rate': 1.0,
            'weekly_rate': 1.0,
            'trend': 'stable',
            'consecutive_errors': 0,
            'total_executions': 0,
            'successful_executions': 0,
            'last_success': None,
            'last_error': None
        }
        
        # „Ç®„É©„ÉºËøΩË∑°„Éá„Éº„Çø„Åã„ÇâË®àÁÆó
        if self.error_file.exists():
            with open(self.error_file, "r", encoding="utf-8") as f:
                error_data = json.load(f)
            
            metrics['consecutive_errors'] = error_data.get("consecutive_errors", 0)
            recent_errors = error_data.get("last_errors", [])
            
            if recent_errors:
                metrics['last_error'] = recent_errors[-1]['timestamp']
        
        # „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É°„Éà„É™„ÇØ„Çπ„Åã„ÇâË©≥Á¥∞Ë®àÁÆó
        if self.metrics_file.exists():
            with open(self.metrics_file, "r", encoding="utf-8") as f:
                performance_data = json.load(f)
            
            # ÈÄ±ÈñìÂÆüË°å„Éá„Éº„Çø„ÇíÂàÜÊûê
            from datetime import datetime, timedelta
            cutoff_date = datetime.now() - timedelta(days=days_back)
            recent_executions = [
                exec_data for exec_data in performance_data.get('executions', [])
                if datetime.fromisoformat(exec_data['timestamp']) > cutoff_date
            ]
            
            if recent_executions:
                metrics['total_executions'] = len(recent_executions)
                metrics['successful_executions'] = sum(
                    1 for exec_data in recent_executions 
                    if exec_data.get('success', False)
                )
                metrics['weekly_rate'] = metrics['successful_executions'] / metrics['total_executions']
                
                # ÊúÄÊñ∞ÊàêÂäüÊó•ÊôÇ
                successful_executions = [
                    exec_data for exec_data in recent_executions 
                    if exec_data.get('success', False)
                ]
                if successful_executions:
                    metrics['last_success'] = successful_executions[-1]['timestamp']
        
        # ÁèæÂú®„ÅÆÊàêÂäüÁéáÔºàÂæìÊù•„É≠„Ç∏„ÉÉ„ÇØÔºâ
        if metrics['consecutive_errors'] == 0:
            metrics['current_rate'] = 1.0
        elif metrics['consecutive_errors'] <= 2:
            metrics['current_rate'] = 0.8
        else:
            metrics['current_rate'] = 0.5
        
        # „Éà„É¨„É≥„ÉâÂàÜÊûê
        if metrics['weekly_rate'] > 0.8:
            metrics['trend'] = 'improving'
        elif metrics['weekly_rate'] < 0.6:
            metrics['trend'] = 'degrading'
        else:
            metrics['trend'] = 'stable'
        
        return metrics
    
    def monitor_system_health(self) -> dict:
        """„Ç∑„Çπ„ÉÜ„É†„Éò„É´„ÇπÁõ£Ë¶ñ"""
        health = {
            'status': 'healthy',
            'alerts': [],
            'warnings': [],
            'last_check': datetime.now().isoformat(),
            'uptime_info': {},
            'performance_summary': {}
        }
        
        # ÊàêÂäüÁéá„ÉÅ„Çß„ÉÉ„ÇØ
        metrics = self.calculate_success_rate()
        current_rate = metrics['current_rate']
        weekly_rate = metrics['weekly_rate']
        
        # ÊàêÂäüÁéá„Ç¢„É©„Éº„Éà
        if current_rate <= self.health_thresholds['success_rate_critical']:
            health['status'] = 'critical'
            health['alerts'].append({
                'type': 'success_rate_critical',
                'message': f"ÊàêÂäüÁéá„ÅåÂç±Èô∫„É¨„Éô„É´: {current_rate*100:.1f}%",
                'threshold': f"{self.health_thresholds['success_rate_critical']*100:.0f}%",
                'severity': 'high'
            })
        elif current_rate <= self.health_thresholds['success_rate_warning']:
            if health['status'] == 'healthy':
                health['status'] = 'warning'
            health['warnings'].append({
                'type': 'success_rate_warning',
                'message': f"ÊàêÂäüÁéá„Åå‰Ωé‰∏ã: {current_rate*100:.1f}%",
                'threshold': f"{self.health_thresholds['success_rate_warning']*100:.0f}%",
                'severity': 'medium'
            })
        
        # ÈÄ£Á∂ö„Ç®„É©„Éº„ÉÅ„Çß„ÉÉ„ÇØ
        consecutive_errors = metrics['consecutive_errors']
        if consecutive_errors >= self.health_thresholds['consecutive_errors_critical']:
            health['status'] = 'critical'
            health['alerts'].append({
                'type': 'consecutive_errors_critical',
                'message': f"ÈÄ£Á∂ö„Ç®„É©„ÉºÊï∞„ÅåÂç±Èô∫„É¨„Éô„É´: {consecutive_errors}Âõû",
                'threshold': f"{self.health_thresholds['consecutive_errors_critical']}Âõû",
                'severity': 'high'
            })
        elif consecutive_errors >= self.health_thresholds['consecutive_errors_warning']:
            if health['status'] == 'healthy':
                health['status'] = 'warning'
            health['warnings'].append({
                'type': 'consecutive_errors_warning',
                'message': f"ÈÄ£Á∂ö„Ç®„É©„Éº„ÅåÁô∫Áîü: {consecutive_errors}Âõû",
                'threshold': f"{self.health_thresholds['consecutive_errors_warning']}Âõû",
                'severity': 'medium'
            })
        
        # ÂÅúÊ≠¢Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ
        if self.check_suspension_status():
            health['status'] = 'suspended'
            health['alerts'].append({
                'type': 'system_suspended',
                'message': "„Ç∑„Çπ„ÉÜ„É†„Åå‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠",
                'severity': 'high'
            })
        
        # „Ç¢„ÉÉ„Éó„Çø„Ç§„É†ÊÉÖÂ†±
        health['uptime_info'] = {
            'last_success': metrics.get('last_success'),
            'last_error': metrics.get('last_error'),
            'total_executions': metrics.get('total_executions', 0),
            'successful_executions': metrics.get('successful_executions', 0)
        }
        
        # „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË¶ÅÁ¥Ñ
        health['performance_summary'] = {
            'current_success_rate': f"{current_rate*100:.1f}%",
            'weekly_success_rate': f"{weekly_rate*100:.1f}%",
            'trend': metrics['trend'],
            'consecutive_errors': consecutive_errors,
            'system_mode': 'dry_run' if self.dry_run else 'live',
            'gradual_mode': self.gradual_mode
        }
        
        return health
    
    def create_github_alert(self, alert_type: str, message: str, details: dict = None):
        """GitHub Issue „Åß„Ç¢„É©„Éº„Éà‰ΩúÊàê"""
        if not os.environ.get("GITHUB_TOKEN") or self.dry_run:
            # GitHub „Éà„Éº„ÇØ„É≥„Åå„Å™„ÅÑÂ†¥Âêà„ÄÅ„Åæ„Åü„ÅØ„Éâ„É©„Ç§„É©„É≥„ÅÆÂ†¥Âêà„ÅØ„É≠„Ç∞„ÅÆ„Åø
            self.log_action("GITHUB_ALERT_SKIPPED", {
                "alert_type": alert_type,
                "message": message,
                "reason": "no_token_or_dry_run"
            })
            return
        
        try:
            import requests
            
            # Issue ‰ΩúÊàêÁî®„Éá„Éº„Çø
            issue_title = f"üö® Ê•ΩÂ§©ROOMËá™ÂãïÂåñ„Ç¢„É©„Éº„Éà: {alert_type}"
            issue_body = f"""
## „Ç¢„É©„Éº„ÉàË©≥Á¥∞

**Á®ÆÈ°û**: {alert_type}
**„É°„ÉÉ„Çª„Éº„Ç∏**: {message}
**Áô∫ÁîüÊó•ÊôÇ**: {datetime.now().isoformat()}

## „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã
"""
            
            if details:
                for key, value in details.items():
                    issue_body += f"- **{key}**: {value}\n"
            
            issue_body += f"""

## Êé®Â•®ÂØæÂøú
1. „Ç∑„Çπ„ÉÜ„É†„É≠„Ç∞„ÇíÁ¢∫Ë™ç
2. Ê•ΩÂ§©ROOM„Çµ„Ç§„Éà„ÅÆÁä∂ÊÖãÁ¢∫Ë™ç
3. ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÊâãÂãï„Åß„ÅÆ„ÉÜ„Çπ„ÉàÂÆüË°å

---
*„Åì„ÅÆIssue„ÅØÊ•ΩÂ§©ROOMËá™ÂãïÂåñ„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„ÇäËá™Âãï‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü*
"""
            
            # GitHub API „É™„ÇØ„Ç®„Çπ„Éà
            headers = {
                "Authorization": f"token {os.environ['GITHUB_TOKEN']}",
                "Accept": "application/vnd.github.v3+json"
            }
            
            data = {
                "title": issue_title,
                "body": issue_body,
                "labels": ["alert", "automation", "monitoring"]
            }
            
            response = requests.post(
                "https://api.github.com/repos/sasayosh1/rakuten-room2/issues",
                headers=headers,
                json=data,
                timeout=30
            )
            
            if response.status_code == 201:
                issue_url = response.json()["html_url"]
                self.log_action("GITHUB_ALERT_CREATED", {
                    "alert_type": alert_type,
                    "issue_url": issue_url
                })
                print(f"üîî GitHub „Ç¢„É©„Éº„Éà‰ΩúÊàê: {issue_url}")
            else:
                self.log_action("GITHUB_ALERT_FAILED", {
                    "alert_type": alert_type,
                    "status_code": response.status_code,
                    "error": response.text
                }, "ERROR")
                
        except Exception as e:
            self.log_action("GITHUB_ALERT_ERROR", {
                "alert_type": alert_type,
                "error": str(e)
            }, "ERROR")
    
    def process_health_alerts(self, health: dict):
        """„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÁµêÊûú„Å´Âü∫„Å•„Åè„Ç¢„É©„Éº„ÉàÂá¶ÁêÜ"""
        # ÈáçË¶Å„Å™„Ç¢„É©„Éº„Éà„ÅÆÂ†¥Âêà„ÅÆ„ÅøGitHub Issue‰ΩúÊàê
        for alert in health.get('alerts', []):
            if alert['severity'] == 'high':
                self.create_github_alert(
                    alert['type'],
                    alert['message'],
                    health['performance_summary']
                )
        
        # „Éò„É´„ÇπÁä∂ÊÖã„Çí„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò
        health_file = f"system_health_{date.today().isoformat()}.json"
        with open(health_file, "w", encoding="utf-8") as f:
            json.dump(health, f, ensure_ascii=False, indent=2)
    
    def record_execution_metrics(self, execution_data: dict):
        """ÂÆüË°å„É°„Éà„É™„ÇØ„Çπ„ÇíË®òÈå≤"""
        metrics_data = {
            'executions': [],
            'summary': {
                'total_executions': 0,
                'successful_executions': 0,
                'failed_executions': 0,
                'last_updated': datetime.now().isoformat()
            }
        }
        
        # Êó¢Â≠ò„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø
        if self.metrics_file.exists():
            with open(self.metrics_file, "r", encoding="utf-8") as f:
                metrics_data = json.load(f)
        
        # Êñ∞„Åó„ÅÑÂÆüË°å„Éá„Éº„Çø„ÇíËøΩÂä†
        execution_record = {
            'timestamp': datetime.now().isoformat(),
            'success': execution_data.get('success', False),
            'posted_count': execution_data.get('posted_count', 0),
            'target_count': execution_data.get('target_count', 0),
            'mode': execution_data.get('mode', 'unknown'),
            'execution_time': execution_data.get('execution_time', 0),
            'errors': execution_data.get('errors', []),
            'dry_run': self.dry_run,
            'gradual_mode': self.gradual_mode
        }
        
        metrics_data['executions'].append(execution_record)
        
        # Áõ¥Ëøë100‰ª∂„ÅÆ„Åø‰øùÊåÅ
        metrics_data['executions'] = metrics_data['executions'][-100:]
        
        # „Çµ„Éû„É™„ÉºÊõ¥Êñ∞
        total_execs = len(metrics_data['executions'])
        successful_execs = sum(1 for exec_data in metrics_data['executions'] if exec_data['success'])
        
        metrics_data['summary'].update({
            'total_executions': total_execs,
            'successful_executions': successful_execs,
            'failed_executions': total_execs - successful_execs,
            'success_rate': successful_execs / total_execs if total_execs > 0 else 0,
            'last_updated': datetime.now().isoformat()
        })
        
        # „Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò
        with open(self.metrics_file, "w", encoding="utf-8") as f:
            json.dump(metrics_data, f, ensure_ascii=False, indent=2)
        
        self.log_action("METRICS_RECORDED", execution_record)
    
    def generate_performance_report(self) -> dict:
        """„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„ÉàÁîüÊàê"""
        report = {
            'report_date': datetime.now().isoformat(),
            'period_summary': {},
            'trend_analysis': {},
            'recommendations': []
        }
        
        if not self.metrics_file.exists():
            report['period_summary'] = {'message': '„Éá„Éº„Çø‰∏çË∂≥Ôºö„É°„Éà„É™„ÇØ„Çπ„ÅåËìÑÁ©ç„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì'}
            return report
        
        with open(self.metrics_file, "r", encoding="utf-8") as f:
            metrics_data = json.load(f)
        
        executions = metrics_data.get('executions', [])
        if not executions:
            report['period_summary'] = {'message': '„Éá„Éº„Çø‰∏çË∂≥ÔºöÂÆüË°åÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'}
            return report
        
        # ÊúüÈñìÂà•„Çµ„Éû„É™„Éº
        from datetime import timedelta
        now = datetime.now()
        
        # ÈÅéÂéª7Êó•Èñì„ÅÆÂàÜÊûê
        week_cutoff = now - timedelta(days=7)
        week_execs = [
            exec_data for exec_data in executions
            if datetime.fromisoformat(exec_data['timestamp']) > week_cutoff
        ]
        
        # ÈÅéÂéª30Êó•Èñì„ÅÆÂàÜÊûê
        month_cutoff = now - timedelta(days=30)
        month_execs = [
            exec_data for exec_data in executions
            if datetime.fromisoformat(exec_data['timestamp']) > month_cutoff
        ]
        
        report['period_summary'] = {
            'week_stats': {
                'total': len(week_execs),
                'successful': sum(1 for e in week_execs if e['success']),
                'success_rate': sum(1 for e in week_execs if e['success']) / len(week_execs) if week_execs else 0
            },
            'month_stats': {
                'total': len(month_execs),
                'successful': sum(1 for e in month_execs if e['success']),
                'success_rate': sum(1 for e in month_execs if e['success']) / len(month_execs) if month_execs else 0
            }
        }
        
        # „Éà„É¨„É≥„ÉâÂàÜÊûê
        week_rate = report['period_summary']['week_stats']['success_rate']
        month_rate = report['period_summary']['month_stats']['success_rate']
        
        if week_rate > month_rate + 0.1:
            trend = 'improving'
        elif week_rate < month_rate - 0.1:
            trend = 'degrading'
        else:
            trend = 'stable'
        
        report['trend_analysis'] = {
            'trend': trend,
            'week_vs_month': f"{(week_rate - month_rate)*100:+.1f}%",
            'confidence': 'high' if len(week_execs) >= 3 else 'low'
        }
        
        # Êé®Â•®‰∫ãÈ†Ö
        if week_rate < 0.7:
            report['recommendations'].append("ÊàêÂäüÁéá„Åå‰Ωé‰∏ã„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Ç∑„Çπ„ÉÜ„É†„ÅÆÁÇπÊ§ú„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ")
        if trend == 'degrading':
            report['recommendations'].append("ÊàêÂäüÁéá„ÅåÊÇ™ÂåñÂÇæÂêë„Åß„Åô„ÄÇÊ•ΩÂ§©ROOM„Çµ„Ç§„Éà„ÅÆÂ§âÊõ¥Á¢∫Ë™ç„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ")
        if len(week_execs) == 0:
            report['recommendations'].append("ÂÆüË°åÈ†ªÂ∫¶„Åå‰Ωé„Åô„Åé„Åæ„Åô„ÄÇË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        
        if not report['recommendations']:
            report['recommendations'].append("„Ç∑„Çπ„ÉÜ„É†„ÅØÊ≠£Â∏∏„Å´Âãï‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ")
        
        return report
    
    def should_allow_posting(self) -> bool:
        """ÊÆµÈöéÁöÑÂÆüË°å„É¢„Éº„ÉâÔºöÊäïÁ®ø„ÇíË®±ÂèØ„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        if not self.gradual_mode:
            return True  # ÊÆµÈöéÁöÑ„É¢„Éº„Éâ„ÅåÁÑ°Âäπ„Å™„ÇâÂ∏∏„Å´Ë®±ÂèØ
        
        metrics = self.calculate_success_rate()
        success_rate = metrics['current_rate']
        
        print(f"üìä „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã:")
        print(f"   ÁèæÂú®„ÅÆÊàêÂäüÁéá: {success_rate*100:.1f}%")
        print(f"   ÈÄ±ÈñìÊàêÂäüÁéá: {metrics['weekly_rate']*100:.1f}%")
        print(f"   ÈÄ£Á∂ö„Ç®„É©„Éº: {metrics['consecutive_errors']}Âõû")
        print(f"   „Éà„É¨„É≥„Éâ: {metrics['trend']}")
        
        if success_rate >= self.success_threshold:
            print(f"‚úÖ ÊàêÂäüÁéá„ÅåÈñæÂÄ§({self.success_threshold*100:.0f}%)‰ª•‰∏ä„ÅÆ„Åü„ÇÅÊäïÁ®ø„ÇíÂÆüË°å")
            return True
        else:
            print(f"‚ö†Ô∏è  ÊàêÂäüÁéá„ÅåÈñæÂÄ§({self.success_threshold*100:.0f}%)Êú™Ê∫Ä„ÅÆ„Åü„ÇÅ„Éâ„É©„Ç§„É©„É≥„ÅÆ„ÅøÂÆüË°å")
            return False
    
    def get_products_to_post(self, max_count: int = 3) -> List[Dict]:
        """ÊäïÁ®øÁî®ÂïÜÂìÅ„Éá„Éº„ÇøÂèñÂæó"""
        products = []
        
        try:
            worksheets = self.sh.worksheets()
            
            for worksheet in worksheets:
                try:
                    data = worksheet.get_all_values()
                    if len(data) <= 1:
                        continue
                    
                    rows = data[1:]  # „Éò„ÉÉ„ÉÄ„ÉºÈô§„Åè
                    
                    for row in rows:
                        if len(row) < 3 or not row[1]:  # URL„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                            continue
                        
                        product = {
                            'title': row[0] if len(row) > 0 else '',
                            'url': row[1] if len(row) > 1 else '',
                            'price': row[2] if len(row) > 2 else '',
                            'description': row[6] if len(row) > 6 else row[0],
                            'sheet_name': worksheet.title
                        }
                        
                        products.append(product)
                        
                        if len(products) >= max_count:
                            break
                    
                    if len(products) >= max_count:
                        break
                        
                except Exception as e:
                    print(f"„Ç∑„Éº„ÉàË™≠„ÅøËæº„Åø„Ç®„É©„Éº: {worksheet.title} - {e}")
                    continue
        
        except Exception as e:
            print(f"„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
        
        return products[:max_count]
    
    def post_to_room(self, products: List[Dict]) -> int:
        """Ê•ΩÂ§©ROOM„Å´ÊäïÁ®ø"""
        if not products:
            print("ÊäïÁ®ø„Åô„ÇãÂïÜÂìÅ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
            return 0
        
        # Êó•Ê¨°Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        daily_stats = self.get_daily_stats()
        if daily_stats["posts"] >= self.daily_limit:
            print(f"Êú¨Êó•„ÅÆÊäïÁ®øÂà∂Èôê„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô: {daily_stats['posts']}/{self.daily_limit}")
            return 0
        
        posted_count = 0
        
        with sync_playwright() as p:
            browser = p.chromium.launch(
                headless=True,
                args=['--no-sandbox', '--disable-dev-shm-usage', '--disable-gpu']
            )
            context = browser.new_context(
                user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            )
            page = context.new_page()
            
            try:
                # „É≠„Ç∞„Ç§„É≥
                if not self._login(page):
                    return 0
                
                # ÊäïÁ®øÂá¶ÁêÜ
                for i, product in enumerate(products):
                    if daily_stats["posts"] + posted_count >= self.daily_limit:
                        print("Êó•Ê¨°Âà∂Èôê„Å´ÈÅî„Åó„Åü„Åü„ÇÅÊäïÁ®ø„ÇíÂÅúÊ≠¢")
                        break
                    
                    try:
                        if self._post_product(page, product):
                            posted_count += 1
                            print(f"ÊäïÁ®øÊàêÂäü: {product['title'][:30]}...")
                            
                            # Áµ±Ë®àÊõ¥Êñ∞
                            self.update_daily_stats(daily_stats["posts"] + posted_count)
                            
                            # ÊäïÁ®øÈñìÈöîÔºà5-10ÂàÜÔºâ
                            if i < len(products) - 1:
                                delay = random.uniform(300, 600)
                                print(f"Ê¨°„ÅÆÊäïÁ®ø„Åæ„Åß {delay/60:.1f}ÂàÜ ÂæÖÊ©ü...")
                                time.sleep(delay)
                        else:
                            print(f"ÊäïÁ®øÂ§±Êïó: {product['title'][:30]}...")
                            
                    except Exception as e:
                        print(f"ÊäïÁ®ø„Ç®„É©„Éº: {e}")
                        continue
            
            finally:
                browser.close()
        
        print(f"ÊäïÁ®øÂÆå‰∫Ü: {posted_count}‰ª∂")
        return posted_count
    
    def _login(self, page) -> bool:
        """Ê•ΩÂ§©ROOM„Å´„É≠„Ç∞„Ç§„É≥"""
        try:
            print("Ê•ΩÂ§©ROOM„Å´„É≠„Ç∞„Ç§„É≥‰∏≠...")
            
            page.goto("https://room.rakuten.co.jp/", timeout=30000)
            time.sleep(random.uniform(2, 4))
            
            # „É≠„Ç∞„Ç§„É≥„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ
            page.click('a[href*="login"]', timeout=10000)
            time.sleep(random.uniform(1, 3))
            
            # „É°„Éº„É´„Ç¢„Éâ„É¨„ÇπÂÖ•Âäõ
            page.fill('input[type="email"]', os.environ["ROOM_EMAIL"])
            time.sleep(random.uniform(0.5, 1.5))
            
            # „Éë„Çπ„ÉØ„Éº„ÉâÂÖ•Âäõ
            page.fill('input[type="password"]', os.environ["ROOM_PASSWORD"])
            time.sleep(random.uniform(0.5, 1.5))
            
            # „É≠„Ç∞„Ç§„É≥„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ
            page.click('button[type="submit"]', timeout=10000)
            
            # „É≠„Ç∞„Ç§„É≥ÂÆå‰∫Ü„ÇíÂæÖÊ©ü
            page.wait_for_url("**/room.rakuten.co.jp/**", timeout=15000)
            time.sleep(random.uniform(2, 4))
            
            print("„É≠„Ç∞„Ç§„É≥ÊàêÂäü")
            return True
            
        except Exception as e:
            print(f"„É≠„Ç∞„Ç§„É≥„Ç®„É©„Éº: {e}")
            return False
    
    def _post_product(self, page, product: Dict) -> bool:
        """ÂïÜÂìÅ„ÇíÊäïÁ®ø"""
        try:
            # ÂïÜÂìÅURLÁßªÂãï
            page.goto(product['url'], timeout=30000)
            time.sleep(random.uniform(2, 4))
            
            # „ÄåROOM„Å´ÊäïÁ®ø„Äç„Éú„Çø„É≥„ÇíÊé¢„Åó„Å¶„ÇØ„É™„ÉÉ„ÇØÔºàË§áÊï∞„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊà¶Áï•Ôºâ
            selectors = [
                # Ê®ôÊ∫ñÁöÑ„Å™„Çª„É¨„ÇØ„Çø„Éº
                'button:has-text("ROOM„Å´ÊäïÁ®ø")',
                'a:has-text("ROOM„Å´ÊäïÁ®ø")',
                
                # „Çà„ÇäÂ∫ÉÁØÑÂõ≤„Å™„ÉÜ„Ç≠„Çπ„Éà„Éû„ÉÉ„ÉÅ„É≥„Ç∞
                'button:has-text("ROOM")',
                'a:has-text("ROOM")',
                'button:has-text("ÊäïÁ®ø")',
                'a:has-text("ÊäïÁ®ø")',
                
                # dataÂ±ûÊÄß„Éô„Éº„Çπ
                '[data-testid="post-to-room"]',
                '[data-action="room-post"]',
                '[data-room="post"]',
                
                # „ÇØ„É©„ÇπÂêç„Éô„Éº„Çπ
                '.post-to-room-btn',
                '.room-post-button',
                '.rakuten-room-post',
                
                # ÈÉ®ÂàÜÁöÑ„Å™„ÇØ„É©„ÇπÂêç
                '[class*="room"][class*="post"]',
                '[class*="post"][class*="room"]',
                
                # „Çà„Çä‰∏ÄËà¨ÁöÑ„Å™„Éú„Çø„É≥
                'button[type="button"]',
                'input[type="button"]'
            ]
            
            clicked = False
            for selector in selectors:
                try:
                    page.click(selector, timeout=5000)
                    clicked = True
                    break
                except:
                    continue
            
            if not clicked:
                print("ÊäïÁ®ø„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                return False
            
            time.sleep(random.uniform(1, 3))
            
            # ÊäïÁ®ø„Éï„Ç©„Éº„É†„ÅåË°®Á§∫„Åï„Çå„Çã„Åæ„ÅßÂæÖÊ©ü
            page.wait_for_selector('textarea, input[type="text"]', timeout=10000)
            time.sleep(random.uniform(1, 2))
            
            # Ë™¨ÊòéÊñáÂÖ•ÂäõÔºàË§áÊï∞„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
            description_selectors = [
                'textarea[placeholder*="„Ç≥„É°„É≥„Éà"]',
                'textarea[placeholder*="Ë™¨Êòé"]',
                'textarea[name*="comment"]',
                'textarea[name*="description"]',
                'textarea',
                'input[type="text"][placeholder*="„Ç≥„É°„É≥„Éà"]',
                'input[type="text"][placeholder*="Ë™¨Êòé"]',
                'input[type="text"]',
                '[contenteditable="true"]'
            ]
            
            description_filled = False
            for selector in description_selectors:
                try:
                    page.fill(selector, product['description'])
                    description_filled = True
                    break
                except:
                    continue
            
            if not description_filled:
                print("‚ö†Ô∏è  Ë™¨ÊòéÊñáÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
            
            time.sleep(random.uniform(1, 2))
            
            # ÊäïÁ®ø„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÔºàË§áÊï∞„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
            submit_selectors = [
                # „ÉÜ„Ç≠„Çπ„Éà„Éô„Éº„Çπ
                'button:has-text("ÊäïÁ®ø„Åô„Çã")',
                'button:has-text("ÊäïÁ®ø")',
                'button:has-text("ÈÄÅ‰ø°")',
                'button:has-text("ÂÆå‰∫Ü")',
                'a:has-text("ÊäïÁ®ø")',
                
                # Â±ûÊÄß„Éô„Éº„Çπ
                'button[type="submit"]',
                'input[type="submit"]',
                'button[value="ÊäïÁ®ø"]',
                
                # „ÇØ„É©„ÇπÂêç„Éô„Éº„Çπ
                '.submit-btn',
                '.post-btn',
                '.send-btn',
                '[class*="submit"]',
                '[class*="post"]',
                
                # „Çà„Çä‰∏ÄËà¨ÁöÑ
                'form button:last-child',
                'button:last-child'
            ]
            
            submit_clicked = False
            for selector in submit_selectors:
                try:
                    page.click(selector, timeout=5000)
                    submit_clicked = True
                    break
                except:
                    continue
            
            if not submit_clicked:
                print("‚ö†Ô∏è  ÊäïÁ®ø„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                return False
            
            # ÊäïÁ®øÂÆå‰∫Ü„ÇíÁ¢∫Ë™ç
            time.sleep(3)
            
            return True
            
        except Exception as e:
            print(f"ÊäïÁ®ø„Ç®„É©„Éº: {e}")
            return False


def main():
    """„É°„Ç§„É≥ÂÆüË°å"""
    start_time = datetime.now()
    execution_errors = []
    
    try:
        poster = RoomPoster()
        
        # „Ç∑„Çπ„ÉÜ„É†„Éò„É´„ÇπÁõ£Ë¶ñ
        health = poster.monitor_system_health()
        poster.process_health_alerts(health)
        
        print(f"üè• „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã: {health['status']}")
        if health['alerts']:
            print(f"üö® „Ç¢„É©„Éº„Éà: {len(health['alerts'])}‰ª∂")
        if health['warnings']:
            print(f"‚ö†Ô∏è  Ë≠¶Âëä: {len(health['warnings'])}‰ª∂")
        
        # ÂÅúÊ≠¢Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ
        if poster.check_suspension_status():
            poster.log_action("EXECUTION_SKIPPED", {"reason": "system_suspended"}, "WARNING")
            print("„Ç∑„Çπ„ÉÜ„É†ÂÅúÊ≠¢‰∏≠„ÅÆ„Åü„ÇÅÂÆüË°å„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô")
            
            # „É°„Éà„É™„ÇØ„ÇπË®òÈå≤
            execution_time = (datetime.now() - start_time).total_seconds()
            poster.record_execution_metrics({
                'success': False,
                'posted_count': 0,
                'target_count': 0,
                'mode': 'suspended',
                'execution_time': execution_time,
                'errors': ['system_suspended']
            })
            return 0
        
        # ÊäïÁ®øÂèØËÉΩÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
        daily_stats = poster.get_daily_stats()
        remaining = poster.daily_limit - daily_stats["posts"]
        
        if remaining <= 0:
            print("Êú¨Êó•„ÅÆÊäïÁ®øÂà∂Èôê„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô")
            return 0
        
        print(f"Êú¨Êó•„ÅÆÊÆã„ÇäÊäïÁ®øÂèØËÉΩÊï∞: {remaining}")
        
        # ÂïÜÂìÅ„Éá„Éº„ÇøÂèñÂæó
        products = poster.get_products_to_post(remaining)
        if not products:
            print("ÊäïÁ®ø„Åô„ÇãÂïÜÂìÅ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
            return 0
        
        print(f"ÊäïÁ®ø‰∫àÂÆöÂïÜÂìÅÊï∞: {len(products)}")
        
        # ÂÆüË°å„É¢„Éº„ÉâÊ±∫ÂÆöÔºà„Éâ„É©„Ç§„É©„É≥/ÊÆµÈöéÁöÑÂÆüË°å/ÈÄöÂ∏∏ÊäïÁ®øÔºâ
        if poster.dry_run:
            poster.log_action("MODE_SELECTED", {"mode": "dry_run", "reason": "dry_run_enabled"})
            posted_count = poster.dry_run_mode(products)
        elif poster.gradual_mode and not poster.should_allow_posting():
            # ÊÆµÈöéÁöÑÂÆüË°å„É¢„Éº„Éâ„ÅßÊàêÂäüÁéá„Åå‰Ωé„ÅÑÂ†¥Âêà„ÅØ„Éâ„É©„Ç§„É©„É≥„ÅÆ„Åø
            poster.log_action("MODE_SELECTED", {"mode": "dry_run", "reason": "gradual_mode_low_success_rate"})
            posted_count = poster.dry_run_mode(products)
        else:
            poster.log_action("MODE_SELECTED", {"mode": "live_posting", "reason": "normal_execution"})
            posted_count = poster.post_to_room(products)
        
        # ÁµêÊûú„Å´Âøú„Åò„Å¶ÊàêÂäü/Â§±Êïó„ÇíË®òÈå≤
        execution_time = (datetime.now() - start_time).total_seconds()
        execution_mode = 'dry_run' if poster.dry_run else ('gradual' if poster.gradual_mode else 'live')
        
        if posted_count > 0:
            poster.record_success()
            poster.log_action("EXECUTION_SUCCESS", {"posted_count": posted_count, "products_count": len(products)})
            print(f"‚úÖ ÊäïÁ®øÊàêÂäü: {posted_count}‰ª∂")
            
            # ÊàêÂäü„É°„Éà„É™„ÇØ„ÇπË®òÈå≤
            poster.record_execution_metrics({
                'success': True,
                'posted_count': posted_count,
                'target_count': len(products),
                'mode': execution_mode,
                'execution_time': execution_time,
                'errors': execution_errors
            })
        else:
            poster.record_error("POST_FAILURE", "ÊäïÁ®ø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
            poster.log_action("EXECUTION_FAILURE", {"posted_count": 0, "products_count": len(products)}, "ERROR")
            print("‚ùå ÊäïÁ®øÂ§±Êïó")
            
            # Â§±Êïó„É°„Éà„É™„ÇØ„ÇπË®òÈå≤
            execution_errors.append("post_failure")
            poster.record_execution_metrics({
                'success': False,
                'posted_count': 0,
                'target_count': len(products),
                'mode': execution_mode,
                'execution_time': execution_time,
                'errors': execution_errors
            })
        
        # „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„ÉàÁîüÊàêÔºàÈÄ±Ê¨°Ôºâ
        if datetime.now().weekday() == 0:  # ÊúàÊõúÊó•
            report = poster.generate_performance_report()
            report_file = f"performance_report_{date.today().isoformat()}.json"
            with open(report_file, "w", encoding="utf-8") as f:
                json.dump(report, f, ensure_ascii=False, indent=2)
            print(f"üìä ÈÄ±Ê¨°„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„ÉàÁîüÊàê: {report_file}")
        
        return posted_count
        
    except Exception as e:
        print(f"‚ùå „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº: {e}")
        try:
            poster = RoomPoster()
            poster.record_error("SYSTEM_ERROR", str(e))
            
            # „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº„ÅÆ„É°„Éà„É™„ÇØ„ÇπË®òÈå≤
            execution_time = (datetime.now() - start_time).total_seconds()
            execution_errors.append(f"system_error: {str(e)}")
            poster.record_execution_metrics({
                'success': False,
                'posted_count': 0,
                'target_count': 0,
                'mode': 'error',
                'execution_time': execution_time,
                'errors': execution_errors
            })
        except:
            pass
        return 0


if __name__ == "__main__":
    exit(main())